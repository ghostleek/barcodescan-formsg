{"mappings":"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","sources":["<anon>","src/capture-photo-defined.js","src/capture-photo.js","src/utils/clamp.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $c290816263f90981$exports = {};\n\n$parcel$export($c290816263f90981$exports, \"CapturePhoto\", function () { return $c290816263f90981$export$cc30a98fe3890794; });\n// @ts-check\n/**\n * Represents a value that may be of type T, or null.\n *\n * @template T\n * @typedef {T | null} Nullable\n */ /**\n * @typedef {Object} ExtendedMediaTrackCapabilities\n * @property {ULongRange} [width] - The width of the video track.\n * @property {ULongRange} [height] - The height of the video track.\n * @property {ULongRange} [pan] - The pan level of the camera.\n * @property {ULongRange} [tilt] - The tilt level of the camera.\n * @property {ULongRange} [zoom] - The zoom level of the camera.\n * @property {MediaTrackCapabilities} [nativeMediaTrackCapabilities] - The native track capabilities.\n */ /**\n * @typedef {Object} ExtendedMediaTrackConstraints\n * @property {MediaTrackConstraints & {pan: boolean, tilt: boolean, zoom: boolean}} video - The video constraints.\n * @property {MediaTrackConstraints | boolean} audio - The audio constraints.\n */ // @ts-check\n/**\n * Clamps number within the inclusive `min` and `max` bounds,\n * making sure it does not go beyond them on either side.\n * If `min` is greater than `max` the parameters are swapped to support inverted ranges.\n *\n * @param {number} value - The number to clamp.\n * @param {number} lower - The lower bound.\n * @param {number} upper - The upper bound.\n * @throws {TypeError} - If one or more of the arguments passed is not a number.\n * @returns {number} - The clamped number.\n * @example\n *\n * clamp(10, -5, 5);\n * // => 5\n *\n * clamp(-10, -5, 5);\n * // => -5\n *\n * clamp(-15, 0, 100);\n * // => 0\n *\n * clamp(120, 0, 100);\n * // => 100\n *\n * clamp(-5, NaN, 5); // If any of lower or upper bound are `NaN`, they will be converted to `0`.\n * // => 0\n *\n * clamp(120, 100, 0); // The order of lower and upper bounds is reversed (100 > 0)\n * // => 100\n */ const $02ad8beec419df62$export$7d15b64cf5a3a4c4 = (value, lower, upper)=>{\n    if (Number.isNaN(lower)) lower = 0;\n    if (Number.isNaN(upper)) upper = 0;\n    return Math.min(Math.max(value, Math.min(lower, upper)), Math.max(lower, upper));\n};\n\n\nconst $c290816263f90981$var$COMPONENT_NAME = \"capture-photo\";\nconst $c290816263f90981$var$styles = /* css */ `\n  :host {\n    display: block;\n    box-sizing: border-box;\n  }\n\n  :host *,\n  :host *::before,\n  :host *::after {\n    box-sizing: inherit;\n  }\n\n  :host([hidden]),\n  [hidden],\n  ::slotted([hidden]) {\n    display: none;\n  }\n\n  video {\n    display: block;\n  }\n\n  #output:empty {\n    display: none;\n  }\n`;\nconst $c290816263f90981$var$template = document.createElement(\"template\");\n$c290816263f90981$var$template.innerHTML = /* html */ `\n  <style>${$c290816263f90981$var$styles}</style>\n\n  <video part=\"video\" playsinline></video>\n\n  <canvas hidden></canvas>\n\n  <div part=\"actions-container\">\n    <slot name=\"capture-button\">\n      <button part=\"capture-button\" type=\"button\">\n        <slot name=\"capture-button-content\">Capture photo</slot>\n      </button>\n    </slot>\n\n    <slot name=\"facing-mode-button\" hidden>\n      <button part=\"facing-mode-button\" type=\"button\">\n        <slot name=\"facing-mode-button-content\">Toggle facing mode</slot>\n      </button>\n    </slot>\n\n    <slot name=\"actions\"></slot>\n  </div>\n\n  <slot></slot>\n\n  <div part=\"output-container\" id=\"output\"></div>\n`;\n/**\n * @summary A custom element that implements the MediaDevices.getUserMedia() method of the MediaDevices interface to capture a photo in the browser.\n * @documentation https://github.com/georapbox/capture-photo-element\n *\n * @tagname capture-photo This is the default tag name, unless overridden by the `defineCustomElement` method.\n * @extends HTMLElement\n *\n * @property {boolean} autoPlay - Whether or not to start the video stream automatically.\n * @property {boolean} noImage - Whether or not to show the captured image.\n * @property {string} facingMode - The facing mode of the camera.\n * @property {string} cameraResolution - The resolution of the camera.\n * @property {number} pan - The pan value of the camera.\n * @property {number} tilt - The tilt value of the camera.\n * @property {number} zoom - The zoom value of the camera.\n * @property {boolean} loading - Whether or not the video stream is loading.\n * @property {boolean} calculateFileSize - Whether or not to calculate the file size of the captured image.\n *\n * @atttribute {boolean} auto-play - Reflects the autoPlay property.\n * @atttribute {boolean} no-image - Reflects the noImage property.\n * @atttribute {string} facing-mode - Reflects the facingMode property.\n * @atttribute {string} camera-resolution - Reflects the cameraResolution property.\n * @atttribute {number} pan - Reflects the pan property.\n * @atttribute {number} tilt - Reflects the tilt property.\n * @atttribute {number} zoom - Reflects the zoom property.\n * @atttribute {boolean} loading - Reflects the loading property.\n * @atttribute {boolean} calculate-file-size - Reflects the calculateFileSize property.\n *\n * @slot capture-button - The capture button.\n * @slot capture-button-content - The capture button content.\n * @slot facing-mode-button - The facing mode button.\n * @slot facing-mode-button-content - The facing mode button content.\n * @slot actions - The actions container.\n * @slot - A default un-named slot to add content inside the component.\n *\n * @csspart video - The video element.\n * @csspart actions-container - The actions container.\n * @csspart capture-button - The capture button.\n * @csspart facing-mode-button - The facing mode button.\n * @csspart output-container - The output container.\n * @csspart output-image - The output image.\n *\n * @event capture-photo:video-play - Fires when the video stream is successfully playing.\n * @event capture-photo:success - Fires when the photo is successfully captured.\n * @event capture-photo:error - Fires when an error occurs.\n *\n * @method defineCustomElement - Static method. Defines the custom element with the given name.\n * @method isSupported - Static method. Checks if the MediaDevices.getUserMedia() method is supported.\n * @method startVideoStream - Instance method. Starts the video stream.\n * @method stopVideoStream - Instance method. Stops the video stream.\n * @method capture - Instance method. Captures a photo.\n * @method getSupportedConstraints - Instance method. Gets the supported constraints.\n * @method getTrackCapabilities - Instance method. Gets the track capabilities.\n * @method getTrackSettings - Instance method. Gets the track settings.\n */ class $c290816263f90981$export$cc30a98fe3890794 extends HTMLElement {\n    /** @type {MediaTrackSupportedConstraints | {}}*/ #supportedConstraints = {};\n    /** @type {Nullable<MediaStream>} */ #stream = null;\n    /** @type {Nullable<HTMLCanvasElement>} */ #canvasElement = null;\n    /** @type {Nullable<HTMLElement>} */ #outputElement = null;\n    /** @type {Nullable<HTMLVideoElement>} */ #videoElement = null;\n    /** @type {Nullable<HTMLSlotElement>} */ #captureButtonSlot = null;\n    /** @type {Nullable<HTMLButtonElement | Element>} */ #captureButton = null;\n    /** @type {Nullable<HTMLSlotElement>} */ #facingModeButtonSlot = null;\n    /** @type {Nullable<HTMLButtonElement | Element>} */ #facingModeButton = null;\n    constructor(){\n        super();\n        this.#supportedConstraints = this.getSupportedConstraints();\n        if (!this.shadowRoot) {\n            const shadowRoot = this.attachShadow({\n                mode: \"open\"\n            });\n            shadowRoot.appendChild($c290816263f90981$var$template.content.cloneNode(true));\n        }\n    }\n    static get observedAttributes() {\n        return [\n            \"no-image\",\n            \"facing-mode\",\n            \"camera-resolution\",\n            \"pan\",\n            \"tilt\",\n            \"zoom\"\n        ];\n    }\n    /**\n   * Lifecycle method that is called when attributes are changed, added, removed, or replaced.\n   *\n   * @param {string} name - The name of the attribute.\n   * @param {string} oldValue - The old value of the attribute.\n   * @param {string} newValue - The new value of the attribute.\n   */ attributeChangedCallback(name, oldValue, newValue) {\n        if (!this.isConnected) return;\n        /** @type {ExtendedMediaTrackCapabilities} */ const trackCapabilities = this.getTrackCapabilities();\n        const trackSettings = this.getTrackSettings();\n        if (name === \"no-image\" && oldValue !== newValue) this.#emptyOutputElement();\n        if (name === \"facing-mode\" && oldValue !== newValue && \"facingMode\" in this.#supportedConstraints) {\n            const isValidFacingMode = [\n                \"user\",\n                \"environment\"\n            ].includes(this.facingMode || \"\");\n            if (\"facingMode\" in trackSettings && isValidFacingMode) {\n                this.stopVideoStream();\n                this.startVideoStream();\n            }\n        }\n        if (name === \"camera-resolution\" && oldValue !== newValue) {\n            if (typeof this.cameraResolution === \"string\" && this.cameraResolution.trim().length > 0) {\n                const [width = 0, height = 0] = this.cameraResolution.split(\"x\").map((x)=>Number(x));\n                if (width > 0 && height > 0 && \"width\" in trackCapabilities && \"height\" in trackCapabilities) {\n                    const widthInAllowedRange = trackCapabilities.width?.min && trackCapabilities.width?.max ? width >= trackCapabilities?.width?.min && width <= trackCapabilities?.width?.max : false;\n                    const heightInAllowedRange = trackCapabilities.height?.min && trackCapabilities.height?.max ? height >= trackCapabilities?.height?.min && height <= trackCapabilities?.height?.max : false;\n                    if (\"width\" in trackSettings && \"height\" in trackSettings && widthInAllowedRange && heightInAllowedRange) {\n                        this.stopVideoStream();\n                        this.startVideoStream();\n                    }\n                }\n            }\n        }\n        if (name === \"pan\" && oldValue !== newValue && \"pan\" in this.#supportedConstraints) {\n            const panInAllowedRange = \"pan\" in trackCapabilities && trackCapabilities.pan?.min && trackCapabilities.pan?.max ? this.pan >= trackCapabilities.pan.min && this.pan <= trackCapabilities.pan.max : false;\n            if (\"pan\" in trackSettings && typeof this.pan === \"number\" && panInAllowedRange) this.#applyPTZ(\"pan\", this.pan);\n        }\n        if (name === \"tilt\" && oldValue !== newValue && \"tilt\" in this.#supportedConstraints) {\n            const tiltInAllowedRange = \"tilt\" in trackCapabilities && trackCapabilities.tilt?.min && trackCapabilities.tilt?.max ? this.tilt >= trackCapabilities.tilt.min && this.tilt <= trackCapabilities.tilt.max : false;\n            if (\"tilt\" in trackSettings && typeof this.tilt === \"number\" && tiltInAllowedRange) this.#applyPTZ(\"tilt\", this.tilt);\n        }\n        if (name === \"zoom\" && oldValue !== newValue && \"zoom\" in this.#supportedConstraints) {\n            const zoomInAllowedRange = \"zoom\" in trackCapabilities && trackCapabilities.zoom?.min && trackCapabilities.zoom?.max ? this.zoom >= trackCapabilities.zoom.min && this.zoom <= trackCapabilities.zoom.max : false;\n            if (\"zoom\" in trackSettings && typeof this.zoom === \"number\" && zoomInAllowedRange) this.#applyPTZ(\"zoom\", this.zoom);\n        }\n    }\n    /**\n   * Lifecycle method that is called when the element is added to the DOM.\n   */ connectedCallback() {\n        this.#upgradeProperty(\"autpoPlay\");\n        this.#upgradeProperty(\"noImage\");\n        this.#upgradeProperty(\"facingMode\");\n        this.#upgradeProperty(\"cameraResolution\");\n        this.#upgradeProperty(\"pan\");\n        this.#upgradeProperty(\"tilt\");\n        this.#upgradeProperty(\"zoom\");\n        this.#upgradeProperty(\"calculateFileSize\");\n        this.#canvasElement = this.shadowRoot?.querySelector(\"canvas\") || null;\n        this.#outputElement = this.shadowRoot?.getElementById(\"output\") || null;\n        this.#videoElement = this.shadowRoot?.querySelector(\"video\") || null;\n        this.#captureButtonSlot = this.shadowRoot?.querySelector('slot[name=\"capture-button\"]') || null;\n        this.#captureButton = this.#getCaptureButton();\n        this.#facingModeButtonSlot = this.shadowRoot?.querySelector('slot[name=\"facing-mode-button\"]') || null;\n        this.#facingModeButton = this.#getFacingModeButton();\n        this.#videoElement?.addEventListener(\"loadedmetadata\", this.#onVideoLoadedMetaData);\n        this.#captureButtonSlot?.addEventListener(\"slotchange\", this.#onCaptureButtonSlotChange);\n        this.#captureButton?.addEventListener(\"click\", this.#onCapturePhotoButtonClick);\n        this.#facingModeButtonSlot?.addEventListener(\"slotchange\", this.#onFacingModeButtonSlotChange);\n        this.#facingModeButton?.addEventListener(\"click\", this.#onFacingModeButtonClick);\n        if (!$c290816263f90981$export$cc30a98fe3890794.isSupported()) return this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:error`, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                error: {\n                    name: \"NotSupportedError\",\n                    message: \"Not supported\"\n                }\n            }\n        }));\n        if (this.autoPlay) this.startVideoStream();\n    }\n    /**\n   * Lifecycle method that is called when the element is removed from the DOM.\n   */ disconnectedCallback() {\n        this.stopVideoStream();\n        this.#facingModeButton?.removeEventListener(\"click\", this.#onFacingModeButtonClick);\n        this.#captureButton?.removeEventListener(\"click\", this.#onCapturePhotoButtonClick);\n        this.#videoElement?.removeEventListener(\"canplay\", this.#onVideoLoadedMetaData);\n        this.#captureButtonSlot?.removeEventListener(\"slotchange\", this.#onCaptureButtonSlotChange);\n        this.#facingModeButtonSlot?.removeEventListener(\"slotchange\", this.#onFacingModeButtonSlotChange);\n    }\n    /**\n   * @type {boolean} autoPlay - Whether or not to start the video stream automatically.\n   * @attribute auto-play - Reflects the autoPlay attribute.\n   */ get autoPlay() {\n        return this.hasAttribute(\"auto-play\");\n    }\n    set autoPlay(value) {\n        this.toggleAttribute(\"auto-play\", !!value);\n    }\n    /**\n   * @type {boolean} noImage - Whether or not to show the captured image.\n   * @attribute no-image - Reflects the noImage attribute.\n   */ get noImage() {\n        return this.hasAttribute(\"no-image\");\n    }\n    set noImage(value) {\n        this.toggleAttribute(\"no-image\", !!value);\n    }\n    /**\n   * @type {string} facingMode - The facing mode of the camera.\n   * @attribute facing-mode - Reflects the facingMode attribute.\n   */ get facingMode() {\n        return this.getAttribute(\"facing-mode\") || \"user\";\n    }\n    set facingMode(value) {\n        this.setAttribute(\"facing-mode\", value);\n    }\n    /**\n   * @type {string} cameraResolution - The resolution of the camera.\n   * @attribute camera-resolution - Reflects the cameraResolution attribute.\n   */ get cameraResolution() {\n        return this.getAttribute(\"camera-resolution\") || \"\";\n    }\n    set cameraResolution(value) {\n        this.setAttribute(\"camera-resolution\", value);\n    }\n    /**\n   * @type {number} pan - The pan value of the camera.\n   * @attribute pan - Reflects the pan attribute.\n   */ get pan() {\n        return Number(this.getAttribute(\"pan\")) || 0;\n    }\n    set pan(value) {\n        this.setAttribute(\"pan\", value != null ? value.toString() : value);\n    }\n    /**\n   * @type {number} tilt - The tilt value of the camera.\n   * @attribute tilt - Reflects the tilt attribute.\n   */ get tilt() {\n        return Number(this.getAttribute(\"tilt\")) || 0;\n    }\n    set tilt(value) {\n        this.setAttribute(\"tilt\", value != null ? value.toString() : value);\n    }\n    /**\n   * @type {number} zoom - The zoom value of the camera.\n   * @attribute zoom - Reflects the zoom attribute.\n   */ get zoom() {\n        return Number(this.getAttribute(\"zoom\")) || 1;\n    }\n    set zoom(value) {\n        this.setAttribute(\"zoom\", value != null ? value.toString() : value);\n    }\n    /**\n   * @type {boolean} loading - Whether or not the video stream is loading.\n   * @attribute loading - Reflects the loading attribute.\n   */ get loading() {\n        return this.hasAttribute(\"loading\");\n    }\n    /**\n   * @type {boolean} calculateFileSize - Whether or not to calculate the file size of the captured image.\n   * @attribute calculate-file-size - Reflects the calculateFileSize attribute.\n   */ get calculateFileSize() {\n        return this.hasAttribute(\"calculate-file-size\");\n    }\n    set calculateFileSize(value) {\n        this.toggleAttribute(\"calculate-file-size\", !!value);\n    }\n    /**\n   * Handles the click event of the facing mode button.\n   *\n   * @param {*} evt - The click event.\n   */ #onFacingModeButtonClick = (evt)=>{\n        evt.preventDefault();\n        if (this.loading) return;\n        this.facingMode = this.facingMode === \"user\" || !this.facingMode ? \"environment\" : \"user\";\n    };\n    /**\n   * Handles the click event of the capture button.\n   *\n   * @param {*} evt - The click event.\n   */ #onCapturePhotoButtonClick = (evt)=>{\n        evt.preventDefault();\n        this.capture();\n    };\n    /**\n   * Handles the loadedmetadata event of the video element.\n   *\n   * @param {*} evt - The loadedmetadata event.\n   */ #onVideoLoadedMetaData = (evt)=>{\n        const video = evt.target;\n        video.play().then(()=>{\n            this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:video-play`, {\n                bubbles: true,\n                composed: true,\n                detail: {\n                    video: video\n                }\n            }));\n        }).catch(/** @param {Error} error */ (error)=>{\n            this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:error`, {\n                bubbles: true,\n                composed: true,\n                detail: {\n                    error: error\n                }\n            }));\n        }).finally(()=>{\n            this.removeAttribute(\"loading\");\n        });\n    };\n    /**\n   * Removes all child nodes from the output element.\n   */ #emptyOutputElement() {\n        if (!this.#outputElement) return;\n        Array.from(this.#outputElement.childNodes).forEach((node)=>node.remove());\n    }\n    /**\n   * Applies the pan, tilt or zoom constraint.\n   *\n   * @param {'pan' | 'tilt' | 'zoom'} constraintName - The name of the constraint.\n   * @param {number} constraintValue - The value of the constraint.\n   */ #applyPTZ(constraintName, constraintValue) {\n        if (!this.#stream || !constraintName || !constraintValue) return;\n        const [track] = this.#stream.getVideoTracks();\n        /** @type {ExtendedMediaTrackCapabilities} */ const trackCapabilities = this.getTrackCapabilities();\n        const trackSettings = this.getTrackSettings();\n        if (constraintName in trackSettings) track.applyConstraints({\n            advanced: [\n                {\n                    [constraintName]: (0, $02ad8beec419df62$export$7d15b64cf5a3a4c4)(Number(constraintValue), trackCapabilities[constraintName]?.min || 1, trackCapabilities[constraintName]?.max || 1)\n                }\n            ]\n        });\n    }\n    /**\n   * Handles the slotchange event of the capture button slot.\n   *\n   * @param {*} evt - The slotchange event.\n   */ #onCaptureButtonSlotChange = (evt)=>{\n        if (evt.target?.name === \"capture-button\") {\n            this.#captureButton?.removeEventListener(\"click\", this.#onCapturePhotoButtonClick);\n            this.#captureButton = this.#getCaptureButton();\n            if (this.#captureButton) {\n                this.#captureButton.addEventListener(\"click\", this.#onCapturePhotoButtonClick);\n                if (this.#captureButton.nodeName !== \"BUTTON\" && !this.#captureButton.hasAttribute(\"role\")) this.#captureButton.setAttribute(\"role\", \"button\");\n            }\n        }\n    };\n    /**\n   * Handles the slotchange event of the facing mode button slot.\n   *\n   * @param {*} evt - The slotchange event.\n   */ #onFacingModeButtonSlotChange = (evt)=>{\n        if (evt.target?.name === \"facing-mode-button\") {\n            this.#facingModeButton?.removeEventListener(\"click\", this.#onFacingModeButtonClick);\n            this.#facingModeButton = this.#getFacingModeButton();\n            if (this.#facingModeButton) {\n                this.#facingModeButton.addEventListener(\"click\", this.#onFacingModeButtonClick);\n                if (this.#facingModeButton.nodeName !== \"BUTTON\" && !this.#facingModeButton.hasAttribute(\"role\")) this.#facingModeButton.setAttribute(\"role\", \"button\");\n            }\n        }\n    };\n    /**\n   * Returns the facing mode button.\n   *\n   * @returns {Nullable<HTMLButtonElement | Element>}\n   */ #getFacingModeButton() {\n        if (!this.#facingModeButtonSlot) return null;\n        return this.#facingModeButtonSlot.assignedElements({\n            flatten: true\n        }).find((el)=>{\n            return el.nodeName === \"BUTTON\" || el.getAttribute(\"slot\") === \"facing-mode-button\";\n        }) || null;\n    }\n    /**\n   * Returns the capture button.\n   *\n   * @returns {Nullable<HTMLButtonElement | Element>}\n   */ #getCaptureButton() {\n        if (!this.#captureButtonSlot) return null;\n        return this.#captureButtonSlot.assignedElements({\n            flatten: true\n        }).find((el)=>{\n            return el.nodeName === \"BUTTON\" || el.getAttribute(\"slot\") === \"capture-button\";\n        }) || null;\n    }\n    /**\n   * This is to safe guard against cases where, for instance, a framework may have added the element to the page and\n   * set a value on one of its properties, but lazy loaded its definition. Without this guard, the upgraded element would\n   * miss that property and the instance property would prevent the class property setter from ever being called.\n   *\n   * https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n   *\n   * @param {'autpoPlay' | 'noImage' | 'facingMode' | 'cameraResolution' | 'pan' | 'tilt' | 'zoom' | 'calculateFileSize'} prop\n   */ #upgradeProperty(prop) {\n        /** @type {any} */ const instance = this;\n        if (Object.prototype.hasOwnProperty.call(instance, prop)) {\n            const value = instance[prop];\n            delete instance[prop];\n            instance[prop] = value;\n        }\n    }\n    /**\n   * Starts the video stream.\n   *\n   * @returns Promise<void>\n   */ async startVideoStream() {\n        if (!$c290816263f90981$export$cc30a98fe3890794.isSupported() || this.#stream) return;\n        this.setAttribute(\"loading\", \"\");\n        /** @type {ExtendedMediaTrackConstraints} */ const constraints = {\n            video: {\n                facingMode: {\n                    ideal: this.facingMode || \"user\"\n                },\n                pan: true,\n                tilt: true,\n                zoom: true\n            },\n            audio: false\n        };\n        if (typeof this.cameraResolution === \"string\" && this.cameraResolution.trim().length > 0) {\n            const [width = 0, height = 0] = this.cameraResolution.split(\"x\").map((x)=>Number(x));\n            if (width > 0 && height > 0) {\n                constraints.video.width = width;\n                constraints.video.height = height;\n            }\n        }\n        try {\n            this.#stream = await navigator.mediaDevices.getUserMedia(constraints);\n            if (this.#videoElement) this.#videoElement.srcObject = this.#stream;\n            this.#applyPTZ(\"pan\", this.pan);\n            this.#applyPTZ(\"tilt\", this.tilt);\n            this.#applyPTZ(\"zoom\", this.zoom);\n            const trackSettings = this.getTrackSettings();\n            if (\"facingMode\" in trackSettings && this.#facingModeButtonSlot) this.#facingModeButtonSlot.hidden = false;\n        } catch (error) {\n            this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:error`, {\n                bubbles: true,\n                composed: true,\n                detail: {\n                    error: error\n                }\n            }));\n        } finally{\n            this.removeAttribute(\"loading\");\n        }\n    }\n    /**\n   * Stops the video stream.\n   */ stopVideoStream() {\n        if (!this.#videoElement || !this.#stream) return;\n        const [track] = this.#stream.getVideoTracks();\n        track?.stop();\n        this.#videoElement.srcObject = null;\n        this.#stream = null;\n    }\n    /**\n   * Captures a photo using the element's properties.\n   *\n   * @returns Promise<void>\n   */ async capture() {\n        if (this.loading || !this.#canvasElement || !this.#videoElement) return;\n        try {\n            const ctx = this.#canvasElement.getContext(\"2d\");\n            const width = this.#videoElement.videoWidth;\n            const height = this.#videoElement.videoHeight;\n            this.#canvasElement.width = width;\n            this.#canvasElement.height = height;\n            ctx?.drawImage(this.#videoElement, 0, 0, width, height);\n            const dataURI = this.#canvasElement.toDataURL(\"image/png\");\n            if (typeof dataURI === \"string\" && dataURI.includes(\"data:image\")) {\n                if (!this.noImage) {\n                    const image = new Image();\n                    image.src = dataURI;\n                    image.width = width;\n                    image.height = height;\n                    image.setAttribute(\"part\", \"output-image\");\n                    this.#emptyOutputElement();\n                    this.#outputElement?.appendChild(image);\n                }\n                /** @type {{ dataURI: string, width: number, height: number, size?: number }} */ const eventDetail = {\n                    dataURI: dataURI,\n                    width: width,\n                    height: height\n                };\n                if (this.calculateFileSize) try {\n                    const file = await fetch(dataURI);\n                    const blob = await file.blob();\n                    const size = blob.size;\n                    if (size) eventDetail.size = size;\n                } catch (err) {\n                // Fail silently...\n                }\n                this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:success`, {\n                    bubbles: true,\n                    composed: true,\n                    detail: eventDetail\n                }));\n            }\n        } catch (error) {\n            this.dispatchEvent(new CustomEvent(`${$c290816263f90981$var$COMPONENT_NAME}:error`, {\n                bubbles: true,\n                composed: true,\n                detail: {\n                    error: error\n                }\n            }));\n        }\n    }\n    /**\n   * Returns an object based on the `MediaTrackSupportedConstraints` dictionary,\n   * whose member fields each specify one ofthe constrainable properties the user agent understands.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaDevices/getSupportedConstraints\n   * @returns {MediaTrackSupportedConstraints | {}}\n   */ getSupportedConstraints() {\n        if (!$c290816263f90981$export$cc30a98fe3890794.isSupported()) return {};\n        return navigator.mediaDevices.getSupportedConstraints() || {};\n    }\n    /**\n   * Returns a `MediaTrackCapabilities` object which specifies the values or range of values\n   * which each constrainable property, based upon the platform and user agent.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaStreamTrack/getCapabilities\n   * @returns {MediaTrackCapabilities | {}}\n   */ getTrackCapabilities() {\n        if (!this.#stream) return {};\n        const [track] = this.#stream.getVideoTracks();\n        if (track && typeof track.getCapabilities === \"function\") return track.getCapabilities() || {};\n        return {};\n    }\n    /**\n   * Returns a `MediaTrackSettings` object containing the current values of each of\n   * the constrainable properties for the current MediaStreamTrack.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaStreamTrack/getSettings\n   * @returns {MediaTrackSettings | {}}\n   */ getTrackSettings() {\n        if (!this.#stream) return {};\n        const [track] = this.#stream.getVideoTracks();\n        if (track && typeof track.getSettings === \"function\") return track.getSettings() || {};\n        return {};\n    }\n    /**\n   * Checks if the `MediaDevices.getUserMedia()` method is supported.\n   *\n   * @returns {boolean}\n   */ static isSupported() {\n        return Boolean(navigator.mediaDevices?.getUserMedia);\n    }\n    /**\n   * Defines a custom element with the given name.\n   * The name must contain a dash (-).\n   *\n   * @param {string} [elementName='capture-photo'] - The name of the custom element.\n   * @example\n   *\n   * CapturePhoto.defineCustomElement('my-capture-photo');\n   */ static defineCustomElement(elementName = $c290816263f90981$var$COMPONENT_NAME) {\n        if (typeof window !== \"undefined\" && !window.customElements.get(elementName)) window.customElements.define(elementName, $c290816263f90981$export$cc30a98fe3890794);\n    }\n}\n\n\n(0, $c290816263f90981$export$cc30a98fe3890794).defineCustomElement();\n\n\nexport {$c290816263f90981$export$cc30a98fe3890794 as CapturePhoto};\n//# sourceMappingURL=capture-photo-defined.js.map\n","import { CapturePhoto } from './capture-photo.js';\n\nCapturePhoto.defineCustomElement();\n\nexport { CapturePhoto };\n","// @ts-check\n\n/**\n * Represents a value that may be of type T, or null.\n *\n * @template T\n * @typedef {T | null} Nullable\n */\n\n/**\n * @typedef {Object} ExtendedMediaTrackCapabilities\n * @property {ULongRange} [width] - The width of the video track.\n * @property {ULongRange} [height] - The height of the video track.\n * @property {ULongRange} [pan] - The pan level of the camera.\n * @property {ULongRange} [tilt] - The tilt level of the camera.\n * @property {ULongRange} [zoom] - The zoom level of the camera.\n * @property {MediaTrackCapabilities} [nativeMediaTrackCapabilities] - The native track capabilities.\n */\n\n/**\n * @typedef {Object} ExtendedMediaTrackConstraints\n * @property {MediaTrackConstraints & {pan: boolean, tilt: boolean, zoom: boolean}} video - The video constraints.\n * @property {MediaTrackConstraints | boolean} audio - The audio constraints.\n */\n\nimport { clamp } from './utils/clamp.js';\n\nconst COMPONENT_NAME = 'capture-photo';\n\nconst styles = /* css */`\n  :host {\n    display: block;\n    box-sizing: border-box;\n  }\n\n  :host *,\n  :host *::before,\n  :host *::after {\n    box-sizing: inherit;\n  }\n\n  :host([hidden]),\n  [hidden],\n  ::slotted([hidden]) {\n    display: none;\n  }\n\n  video {\n    display: block;\n  }\n\n  #output:empty {\n    display: none;\n  }\n`;\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = /* html */`\n  <style>${styles}</style>\n\n  <video part=\"video\" playsinline></video>\n\n  <canvas hidden></canvas>\n\n  <div part=\"actions-container\">\n    <slot name=\"capture-button\">\n      <button part=\"capture-button\" type=\"button\">\n        <slot name=\"capture-button-content\">Capture photo</slot>\n      </button>\n    </slot>\n\n    <slot name=\"facing-mode-button\" hidden>\n      <button part=\"facing-mode-button\" type=\"button\">\n        <slot name=\"facing-mode-button-content\">Toggle facing mode</slot>\n      </button>\n    </slot>\n\n    <slot name=\"actions\"></slot>\n  </div>\n\n  <slot></slot>\n\n  <div part=\"output-container\" id=\"output\"></div>\n`;\n\n/**\n * @summary A custom element that implements the MediaDevices.getUserMedia() method of the MediaDevices interface to capture a photo in the browser.\n * @documentation https://github.com/georapbox/capture-photo-element\n *\n * @tagname capture-photo This is the default tag name, unless overridden by the `defineCustomElement` method.\n * @extends HTMLElement\n *\n * @property {boolean} autoPlay - Whether or not to start the video stream automatically.\n * @property {boolean} noImage - Whether or not to show the captured image.\n * @property {string} facingMode - The facing mode of the camera.\n * @property {string} cameraResolution - The resolution of the camera.\n * @property {number} pan - The pan value of the camera.\n * @property {number} tilt - The tilt value of the camera.\n * @property {number} zoom - The zoom value of the camera.\n * @property {boolean} loading - Whether or not the video stream is loading.\n * @property {boolean} calculateFileSize - Whether or not to calculate the file size of the captured image.\n *\n * @atttribute {boolean} auto-play - Reflects the autoPlay property.\n * @atttribute {boolean} no-image - Reflects the noImage property.\n * @atttribute {string} facing-mode - Reflects the facingMode property.\n * @atttribute {string} camera-resolution - Reflects the cameraResolution property.\n * @atttribute {number} pan - Reflects the pan property.\n * @atttribute {number} tilt - Reflects the tilt property.\n * @atttribute {number} zoom - Reflects the zoom property.\n * @atttribute {boolean} loading - Reflects the loading property.\n * @atttribute {boolean} calculate-file-size - Reflects the calculateFileSize property.\n *\n * @slot capture-button - The capture button.\n * @slot capture-button-content - The capture button content.\n * @slot facing-mode-button - The facing mode button.\n * @slot facing-mode-button-content - The facing mode button content.\n * @slot actions - The actions container.\n * @slot - A default un-named slot to add content inside the component.\n *\n * @csspart video - The video element.\n * @csspart actions-container - The actions container.\n * @csspart capture-button - The capture button.\n * @csspart facing-mode-button - The facing mode button.\n * @csspart output-container - The output container.\n * @csspart output-image - The output image.\n *\n * @event capture-photo:video-play - Fires when the video stream is successfully playing.\n * @event capture-photo:success - Fires when the photo is successfully captured.\n * @event capture-photo:error - Fires when an error occurs.\n *\n * @method defineCustomElement - Static method. Defines the custom element with the given name.\n * @method isSupported - Static method. Checks if the MediaDevices.getUserMedia() method is supported.\n * @method startVideoStream - Instance method. Starts the video stream.\n * @method stopVideoStream - Instance method. Stops the video stream.\n * @method capture - Instance method. Captures a photo.\n * @method getSupportedConstraints - Instance method. Gets the supported constraints.\n * @method getTrackCapabilities - Instance method. Gets the track capabilities.\n * @method getTrackSettings - Instance method. Gets the track settings.\n */\nclass CapturePhoto extends HTMLElement {\n  /** @type {MediaTrackSupportedConstraints | {}}*/\n  #supportedConstraints = {};\n\n  /** @type {Nullable<MediaStream>} */\n  #stream = null;\n\n  /** @type {Nullable<HTMLCanvasElement>} */\n  #canvasElement = null;\n\n  /** @type {Nullable<HTMLElement>} */\n  #outputElement = null;\n\n  /** @type {Nullable<HTMLVideoElement>} */\n  #videoElement = null;\n\n  /** @type {Nullable<HTMLSlotElement>} */\n  #captureButtonSlot = null;\n\n  /** @type {Nullable<HTMLButtonElement | Element>} */\n  #captureButton = null;\n\n  /** @type {Nullable<HTMLSlotElement>} */\n  #facingModeButtonSlot = null;\n\n  /** @type {Nullable<HTMLButtonElement | Element>} */\n  #facingModeButton = null;\n\n  constructor() {\n    super();\n\n    this.#supportedConstraints = this.getSupportedConstraints();\n\n    if (!this.shadowRoot) {\n      const shadowRoot = this.attachShadow({ mode: 'open' });\n      shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n  }\n\n  static get observedAttributes() {\n    return ['no-image', 'facing-mode', 'camera-resolution', 'pan', 'tilt', 'zoom'];\n  }\n\n  /**\n   * Lifecycle method that is called when attributes are changed, added, removed, or replaced.\n   *\n   * @param {string} name - The name of the attribute.\n   * @param {string} oldValue - The old value of the attribute.\n   * @param {string} newValue - The new value of the attribute.\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!this.isConnected) {\n      return;\n    }\n\n    /** @type {ExtendedMediaTrackCapabilities} */\n    const trackCapabilities = this.getTrackCapabilities();\n    const trackSettings = this.getTrackSettings();\n\n    if (name === 'no-image' && oldValue !== newValue) {\n      this.#emptyOutputElement();\n    }\n\n    if (name === 'facing-mode' && oldValue !== newValue && 'facingMode' in this.#supportedConstraints) {\n      const isValidFacingMode = ['user', 'environment'].includes(this.facingMode || '');\n\n      if ('facingMode' in trackSettings && isValidFacingMode) {\n        this.stopVideoStream();\n        this.startVideoStream();\n      }\n    }\n\n    if (name === 'camera-resolution' && oldValue !== newValue) {\n      if (typeof this.cameraResolution === 'string' && this.cameraResolution.trim().length > 0) {\n        const [width = 0, height = 0] = this.cameraResolution.split('x').map(x => Number(x));\n\n        if (width > 0 && height > 0 && 'width' in trackCapabilities && 'height' in trackCapabilities) {\n          const widthInAllowedRange = trackCapabilities.width?.min && trackCapabilities.width?.max\n            ? width >= trackCapabilities?.width?.min && width <= trackCapabilities?.width?.max\n            : false;\n\n          const heightInAllowedRange = trackCapabilities.height?.min && trackCapabilities.height?.max\n            ? height >= trackCapabilities?.height?.min && height <= trackCapabilities?.height?.max\n            : false;\n\n          if ('width' in trackSettings && 'height' in trackSettings && widthInAllowedRange && heightInAllowedRange) {\n            this.stopVideoStream();\n            this.startVideoStream();\n          }\n        }\n      }\n    }\n\n    if (name === 'pan' && oldValue !== newValue && 'pan' in this.#supportedConstraints) {\n      const panInAllowedRange = 'pan' in trackCapabilities && trackCapabilities.pan?.min && trackCapabilities.pan?.max\n        ? this.pan >= trackCapabilities.pan.min && this.pan <= trackCapabilities.pan.max\n        : false;\n\n      if ('pan' in trackSettings && typeof this.pan === 'number' && panInAllowedRange) {\n        this.#applyPTZ('pan', this.pan);\n      }\n    }\n\n    if (name === 'tilt' && oldValue !== newValue && 'tilt' in this.#supportedConstraints) {\n      const tiltInAllowedRange = 'tilt' in trackCapabilities && trackCapabilities.tilt?.min && trackCapabilities.tilt?.max\n        ? this.tilt >= trackCapabilities.tilt.min && this.tilt <= trackCapabilities.tilt.max\n        : false;\n\n      if ('tilt' in trackSettings && typeof this.tilt === 'number' && tiltInAllowedRange) {\n        this.#applyPTZ('tilt', this.tilt);\n      }\n    }\n\n    if (name === 'zoom' && oldValue !== newValue && 'zoom' in this.#supportedConstraints) {\n      const zoomInAllowedRange = 'zoom' in trackCapabilities && trackCapabilities.zoom?.min && trackCapabilities.zoom?.max\n        ? this.zoom >= trackCapabilities.zoom.min && this.zoom <= trackCapabilities.zoom.max\n        : false;\n\n      if ('zoom' in trackSettings && typeof this.zoom === 'number' && zoomInAllowedRange) {\n        this.#applyPTZ('zoom', this.zoom);\n      }\n    }\n  }\n\n  /**\n   * Lifecycle method that is called when the element is added to the DOM.\n   */\n  connectedCallback() {\n    this.#upgradeProperty('autpoPlay');\n    this.#upgradeProperty('noImage');\n    this.#upgradeProperty('facingMode');\n    this.#upgradeProperty('cameraResolution');\n    this.#upgradeProperty('pan');\n    this.#upgradeProperty('tilt');\n    this.#upgradeProperty('zoom');\n    this.#upgradeProperty('calculateFileSize');\n\n    this.#canvasElement = this.shadowRoot?.querySelector('canvas') || null;\n    this.#outputElement = this.shadowRoot?.getElementById('output') || null;\n    this.#videoElement = this.shadowRoot?.querySelector('video') || null;\n    this.#captureButtonSlot = this.shadowRoot?.querySelector('slot[name=\"capture-button\"]') || null;\n    this.#captureButton = this.#getCaptureButton();\n    this.#facingModeButtonSlot = this.shadowRoot?.querySelector('slot[name=\"facing-mode-button\"]') || null;\n    this.#facingModeButton = this.#getFacingModeButton();\n\n    this.#videoElement?.addEventListener('loadedmetadata', this.#onVideoLoadedMetaData);\n    this.#captureButtonSlot?.addEventListener('slotchange', this.#onCaptureButtonSlotChange);\n    this.#captureButton?.addEventListener('click', this.#onCapturePhotoButtonClick);\n    this.#facingModeButtonSlot?.addEventListener('slotchange', this.#onFacingModeButtonSlotChange);\n    this.#facingModeButton?.addEventListener('click', this.#onFacingModeButtonClick);\n\n    if (!CapturePhoto.isSupported()) {\n      return this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:error`, {\n        bubbles: true,\n        composed: true,\n        detail: {\n          error: {\n            name: 'NotSupportedError',\n            message: 'Not supported'\n          }\n        }\n      }));\n    }\n\n    if (this.autoPlay) {\n      this.startVideoStream();\n    }\n  }\n\n  /**\n   * Lifecycle method that is called when the element is removed from the DOM.\n   */\n  disconnectedCallback() {\n    this.stopVideoStream();\n    this.#facingModeButton?.removeEventListener('click', this.#onFacingModeButtonClick);\n    this.#captureButton?.removeEventListener('click', this.#onCapturePhotoButtonClick);\n    this.#videoElement?.removeEventListener('canplay', this.#onVideoLoadedMetaData);\n    this.#captureButtonSlot?.removeEventListener('slotchange', this.#onCaptureButtonSlotChange);\n    this.#facingModeButtonSlot?.removeEventListener('slotchange', this.#onFacingModeButtonSlotChange);\n  }\n\n  /**\n   * @type {boolean} autoPlay - Whether or not to start the video stream automatically.\n   * @attribute auto-play - Reflects the autoPlay attribute.\n   */\n  get autoPlay() {\n    return this.hasAttribute('auto-play');\n  }\n\n  set autoPlay(value) {\n    this.toggleAttribute('auto-play', !!value);\n  }\n\n  /**\n   * @type {boolean} noImage - Whether or not to show the captured image.\n   * @attribute no-image - Reflects the noImage attribute.\n   */\n  get noImage() {\n    return this.hasAttribute('no-image');\n  }\n\n  set noImage(value) {\n    this.toggleAttribute('no-image', !!value);\n  }\n\n  /**\n   * @type {string} facingMode - The facing mode of the camera.\n   * @attribute facing-mode - Reflects the facingMode attribute.\n   */\n  get facingMode() {\n    return this.getAttribute('facing-mode') || 'user';\n  }\n\n  set facingMode(value) {\n    this.setAttribute('facing-mode', value);\n  }\n\n  /**\n   * @type {string} cameraResolution - The resolution of the camera.\n   * @attribute camera-resolution - Reflects the cameraResolution attribute.\n   */\n  get cameraResolution() {\n    return this.getAttribute('camera-resolution') || '';\n  }\n\n  set cameraResolution(value) {\n    this.setAttribute('camera-resolution', value);\n  }\n\n  /**\n   * @type {number} pan - The pan value of the camera.\n   * @attribute pan - Reflects the pan attribute.\n   */\n  get pan() {\n    return Number(this.getAttribute('pan')) || 0;\n  }\n\n  set pan(value) {\n    this.setAttribute('pan', value != null ? value.toString() : value);\n  }\n\n  /**\n   * @type {number} tilt - The tilt value of the camera.\n   * @attribute tilt - Reflects the tilt attribute.\n   */\n  get tilt() {\n    return Number(this.getAttribute('tilt')) || 0;\n  }\n\n  set tilt(value) {\n    this.setAttribute('tilt', value != null ? value.toString() : value);\n  }\n\n  /**\n   * @type {number} zoom - The zoom value of the camera.\n   * @attribute zoom - Reflects the zoom attribute.\n   */\n  get zoom() {\n    return Number(this.getAttribute('zoom')) || 1;\n  }\n\n  set zoom(value) {\n    this.setAttribute('zoom', value != null ? value.toString() : value);\n  }\n\n  /**\n   * @type {boolean} loading - Whether or not the video stream is loading.\n   * @attribute loading - Reflects the loading attribute.\n   */\n  get loading() {\n    return this.hasAttribute('loading');\n  }\n\n  /**\n   * @type {boolean} calculateFileSize - Whether or not to calculate the file size of the captured image.\n   * @attribute calculate-file-size - Reflects the calculateFileSize attribute.\n   */\n  get calculateFileSize() {\n    return this.hasAttribute('calculate-file-size');\n  }\n\n  set calculateFileSize(value) {\n    this.toggleAttribute('calculate-file-size', !!value);\n  }\n\n  /**\n   * Handles the click event of the facing mode button.\n   *\n   * @param {*} evt - The click event.\n   */\n  #onFacingModeButtonClick = evt => {\n    evt.preventDefault();\n\n    if (this.loading) {\n      return;\n    }\n\n    this.facingMode = this.facingMode === 'user' || !this.facingMode ? 'environment' : 'user';\n  };\n\n  /**\n   * Handles the click event of the capture button.\n   *\n   * @param {*} evt - The click event.\n   */\n  #onCapturePhotoButtonClick = evt => {\n    evt.preventDefault();\n    this.capture();\n  };\n\n  /**\n   * Handles the loadedmetadata event of the video element.\n   *\n   * @param {*} evt - The loadedmetadata event.\n   */\n  #onVideoLoadedMetaData = evt => {\n    const video = evt.target;\n\n    video.play().then(() => {\n      this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:video-play`, {\n        bubbles: true,\n        composed: true,\n        detail: { video }\n      }));\n    }).catch(/** @param {Error} error */error => {\n      this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:error`, {\n        bubbles: true,\n        composed: true,\n        detail: { error }\n      }));\n    }).finally(() => {\n      this.removeAttribute('loading');\n    });\n  };\n\n  /**\n   * Removes all child nodes from the output element.\n   */\n  #emptyOutputElement() {\n    if (!this.#outputElement) {\n      return;\n    }\n\n    Array.from(this.#outputElement.childNodes).forEach(node => node.remove());\n  }\n\n  /**\n   * Applies the pan, tilt or zoom constraint.\n   *\n   * @param {'pan' | 'tilt' | 'zoom'} constraintName - The name of the constraint.\n   * @param {number} constraintValue - The value of the constraint.\n   */\n  #applyPTZ(constraintName, constraintValue) {\n    if (!this.#stream || !constraintName || !constraintValue) {\n      return;\n    }\n\n    const [track] = this.#stream.getVideoTracks();\n    /** @type {ExtendedMediaTrackCapabilities} */\n    const trackCapabilities = this.getTrackCapabilities();\n    const trackSettings = this.getTrackSettings();\n\n    if (constraintName in trackSettings) {\n      track.applyConstraints({\n        advanced: [{\n          [constraintName]: clamp(Number(constraintValue), trackCapabilities[constraintName]?.min || 1, trackCapabilities[constraintName]?.max || 1)\n        }]\n      });\n    }\n  }\n\n  /**\n   * Handles the slotchange event of the capture button slot.\n   *\n   * @param {*} evt - The slotchange event.\n   */\n  #onCaptureButtonSlotChange = evt => {\n    if (evt.target?.name === 'capture-button') {\n      this.#captureButton?.removeEventListener('click', this.#onCapturePhotoButtonClick);\n      this.#captureButton = this.#getCaptureButton();\n\n      if (this.#captureButton) {\n        this.#captureButton.addEventListener('click', this.#onCapturePhotoButtonClick);\n\n        if (this.#captureButton.nodeName !== 'BUTTON' && !this.#captureButton.hasAttribute('role')) {\n          this.#captureButton.setAttribute('role', 'button');\n        }\n      }\n    }\n  };\n\n  /**\n   * Handles the slotchange event of the facing mode button slot.\n   *\n   * @param {*} evt - The slotchange event.\n   */\n  #onFacingModeButtonSlotChange = evt => {\n    if (evt.target?.name === 'facing-mode-button') {\n      this.#facingModeButton?.removeEventListener('click', this.#onFacingModeButtonClick);\n      this.#facingModeButton = this.#getFacingModeButton();\n\n      if (this.#facingModeButton) {\n        this.#facingModeButton.addEventListener('click', this.#onFacingModeButtonClick);\n\n        if (this.#facingModeButton.nodeName !== 'BUTTON' && !this.#facingModeButton.hasAttribute('role')) {\n          this.#facingModeButton.setAttribute('role', 'button');\n        }\n      }\n    }\n  };\n\n  /**\n   * Returns the facing mode button.\n   *\n   * @returns {Nullable<HTMLButtonElement | Element>}\n   */\n  #getFacingModeButton() {\n    if (!this.#facingModeButtonSlot) {\n      return null;\n    }\n\n    return this.#facingModeButtonSlot.assignedElements({ flatten: true }).find(el => {\n      return el.nodeName === 'BUTTON' || el.getAttribute('slot') === 'facing-mode-button';\n    }) || null;\n  }\n\n  /**\n   * Returns the capture button.\n   *\n   * @returns {Nullable<HTMLButtonElement | Element>}\n   */\n  #getCaptureButton() {\n    if (!this.#captureButtonSlot) {\n      return null;\n    }\n\n    return this.#captureButtonSlot.assignedElements({ flatten: true }).find(el => {\n      return el.nodeName === 'BUTTON' || el.getAttribute('slot') === 'capture-button';\n    }) || null;\n  }\n\n  /**\n   * This is to safe guard against cases where, for instance, a framework may have added the element to the page and\n   * set a value on one of its properties, but lazy loaded its definition. Without this guard, the upgraded element would\n   * miss that property and the instance property would prevent the class property setter from ever being called.\n   *\n   * https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n   *\n   * @param {'autpoPlay' | 'noImage' | 'facingMode' | 'cameraResolution' | 'pan' | 'tilt' | 'zoom' | 'calculateFileSize'} prop\n   */\n  #upgradeProperty(prop) {\n    /** @type {any} */\n    const instance = this;\n\n    if (Object.prototype.hasOwnProperty.call(instance, prop)) {\n      const value = instance[prop];\n      delete instance[prop];\n      instance[prop] = value;\n    }\n  }\n\n  /**\n   * Starts the video stream.\n   *\n   * @returns Promise<void>\n   */\n  async startVideoStream() {\n    if (!CapturePhoto.isSupported() || this.#stream) {\n      return;\n    }\n\n    this.setAttribute('loading', '');\n\n    /** @type {ExtendedMediaTrackConstraints} */\n    const constraints = {\n      video: {\n        facingMode: {\n          ideal: this.facingMode || 'user'\n        },\n        pan: true,\n        tilt: true,\n        zoom: true\n      },\n      audio: false\n    };\n\n    if (typeof this.cameraResolution === 'string' && this.cameraResolution.trim().length > 0) {\n      const [width = 0, height = 0] = this.cameraResolution.split('x').map(x => Number(x));\n\n      if (width > 0 && height > 0) {\n        constraints.video.width = width;\n        constraints.video.height = height;\n      }\n    }\n\n    try {\n      this.#stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n      if (this.#videoElement) {\n        this.#videoElement.srcObject = this.#stream;\n      }\n\n      this.#applyPTZ('pan', this.pan);\n      this.#applyPTZ('tilt', this.tilt);\n      this.#applyPTZ('zoom', this.zoom);\n\n      const trackSettings = this.getTrackSettings();\n\n      if ('facingMode' in trackSettings && this.#facingModeButtonSlot) {\n        this.#facingModeButtonSlot.hidden = false;\n      }\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:error`, {\n        bubbles: true,\n        composed: true,\n        detail: { error }\n      }));\n    } finally {\n      this.removeAttribute('loading');\n    }\n  }\n\n  /**\n   * Stops the video stream.\n   */\n  stopVideoStream() {\n    if (!this.#videoElement || !this.#stream) {\n      return;\n    }\n\n    const [track] = this.#stream.getVideoTracks();\n\n    track?.stop();\n    this.#videoElement.srcObject = null;\n    this.#stream = null;\n  }\n\n  /**\n   * Captures a photo using the element's properties.\n   *\n   * @returns Promise<void>\n   */\n  async capture() {\n    if (this.loading || !this.#canvasElement || !this.#videoElement) {\n      return;\n    }\n\n    try {\n      const ctx = this.#canvasElement.getContext('2d');\n      const width = this.#videoElement.videoWidth;\n      const height = this.#videoElement.videoHeight;\n      this.#canvasElement.width = width;\n      this.#canvasElement.height = height;\n      ctx?.drawImage(this.#videoElement, 0, 0, width, height);\n      const dataURI = this.#canvasElement.toDataURL('image/png');\n\n      if (typeof dataURI === 'string' && dataURI.includes('data:image')) {\n        if (!this.noImage) {\n          const image = new Image();\n          image.src = dataURI;\n          image.width = width;\n          image.height = height;\n          image.setAttribute('part', 'output-image');\n          this.#emptyOutputElement();\n          this.#outputElement?.appendChild(image);\n        }\n\n        /** @type {{ dataURI: string, width: number, height: number, size?: number }} */\n        const eventDetail = { dataURI, width, height };\n\n        if (this.calculateFileSize) {\n          try {\n            const file = await fetch(dataURI);\n            const blob = await file.blob();\n            const size = blob.size;\n\n            if (size) {\n              eventDetail.size = size;\n            }\n          } catch (err) {\n            // Fail silently...\n          }\n        }\n\n        this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:success`, {\n          bubbles: true,\n          composed: true,\n          detail: eventDetail\n        }));\n      }\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent(`${COMPONENT_NAME}:error`, {\n        bubbles: true,\n        composed: true,\n        detail: { error }\n      }));\n    }\n  }\n\n  /**\n   * Returns an object based on the `MediaTrackSupportedConstraints` dictionary,\n   * whose member fields each specify one ofthe constrainable properties the user agent understands.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaDevices/getSupportedConstraints\n   * @returns {MediaTrackSupportedConstraints | {}}\n   */\n  getSupportedConstraints() {\n    if (!CapturePhoto.isSupported()) {\n      return {};\n    }\n\n    return navigator.mediaDevices.getSupportedConstraints() || {};\n  }\n\n  /**\n   * Returns a `MediaTrackCapabilities` object which specifies the values or range of values\n   * which each constrainable property, based upon the platform and user agent.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaStreamTrack/getCapabilities\n   * @returns {MediaTrackCapabilities | {}}\n   */\n  getTrackCapabilities() {\n    if (!this.#stream) {\n      return {};\n    }\n\n    const [track] = this.#stream.getVideoTracks();\n\n    if (track && typeof track.getCapabilities === 'function') {\n      return track.getCapabilities() || {};\n    }\n\n    return {};\n  }\n\n  /**\n   * Returns a `MediaTrackSettings` object containing the current values of each of\n   * the constrainable properties for the current MediaStreamTrack.\n   *\n   * @see https://developer.mozilla.org/docs/Web/API/MediaStreamTrack/getSettings\n   * @returns {MediaTrackSettings | {}}\n   */\n  getTrackSettings() {\n    if (!this.#stream) {\n      return {};\n    }\n\n    const [track] = this.#stream.getVideoTracks();\n\n    if (track && typeof track.getSettings === 'function') {\n      return track.getSettings() || {};\n    }\n\n    return {};\n  }\n\n  /**\n   * Checks if the `MediaDevices.getUserMedia()` method is supported.\n   *\n   * @returns {boolean}\n   */\n  static isSupported() {\n    return Boolean(navigator.mediaDevices?.getUserMedia);\n  }\n\n  /**\n   * Defines a custom element with the given name.\n   * The name must contain a dash (-).\n   *\n   * @param {string} [elementName='capture-photo'] - The name of the custom element.\n   * @example\n   *\n   * CapturePhoto.defineCustomElement('my-capture-photo');\n   */\n  static defineCustomElement(elementName = COMPONENT_NAME) {\n    if (typeof window !== 'undefined' && !window.customElements.get(elementName)) {\n      window.customElements.define(elementName, CapturePhoto);\n    }\n  }\n}\n\nexport { CapturePhoto };\n","// @ts-check\n\n/**\n * Clamps number within the inclusive `min` and `max` bounds,\n * making sure it does not go beyond them on either side.\n * If `min` is greater than `max` the parameters are swapped to support inverted ranges.\n *\n * @param {number} value - The number to clamp.\n * @param {number} lower - The lower bound.\n * @param {number} upper - The upper bound.\n * @throws {TypeError} - If one or more of the arguments passed is not a number.\n * @returns {number} - The clamped number.\n * @example\n *\n * clamp(10, -5, 5);\n * // => 5\n *\n * clamp(-10, -5, 5);\n * // => -5\n *\n * clamp(-15, 0, 100);\n * // => 0\n *\n * clamp(120, 0, 100);\n * // => 100\n *\n * clamp(-5, NaN, 5); // If any of lower or upper bound are `NaN`, they will be converted to `0`.\n * // => 0\n *\n * clamp(120, 100, 0); // The order of lower and upper bounds is reversed (100 > 0)\n * // => 100\n */\nexport const clamp = (value, lower, upper) => {\n  if (Number.isNaN(lower)) {\n    lower = 0;\n  }\n\n  if (Number.isNaN(upper)) {\n    upper = 0;\n  }\n\n  return Math.min(Math.max(value, Math.min(lower, upper)), Math.max(lower, upper));\n};\n"],"names":["Object","defineProperty","get","$c290816263f90981$export$cc30a98fe3890794","set","s","enumerable","configurable","$02ad8beec419df62$export$7d15b64cf5a3a4c4","value","lower","upper","Number","isNaN","Math","min","max","$c290816263f90981$var$COMPONENT_NAME","$c290816263f90981$var$styles","$c290816263f90981$var$template","document","createElement","innerHTML","HTMLElement","supportedConstraints","stream","canvasElement","outputElement","videoElement","captureButtonSlot","captureButton","facingModeButtonSlot","facingModeButton","constructor","getSupportedConstraints","shadowRoot","attachShadow","mode","appendChild","content","cloneNode","observedAttributes","attributeChangedCallback","name","oldValue","newValue","isConnected","trackCapabilities","getTrackCapabilities","trackSettings","getTrackSettings","emptyOutputElement","isValidFacingMode","includes","facingMode","stopVideoStream","startVideoStream","cameraResolution","trim","length","width","height","split","map","x","widthInAllowedRange","heightInAllowedRange","panInAllowedRange","pan","applyPTZ","tiltInAllowedRange","tilt","zoomInAllowedRange","zoom","connectedCallback","upgradeProperty","querySelector","getElementById","getCaptureButton","getFacingModeButton","addEventListener","onVideoLoadedMetaData","onCaptureButtonSlotChange","onCapturePhotoButtonClick","onFacingModeButtonSlotChange","onFacingModeButtonClick","isSupported","dispatchEvent","CustomEvent","bubbles","composed","detail","error","message","autoPlay","disconnectedCallback","removeEventListener","hasAttribute","toggleAttribute","noImage","getAttribute","setAttribute","toString","loading","calculateFileSize","evt","preventDefault","capture","video","target","play","then","catch","finally","removeAttribute","Array","from","childNodes","forEach","node","remove","constraintName","constraintValue","track","getVideoTracks","applyConstraints","advanced","nodeName","assignedElements","flatten","find","el","prop","prototype","hasOwnProperty","call","instance","constraints","ideal","audio","navigator","mediaDevices","getUserMedia","srcObject","hidden","stop","ctx","getContext","videoWidth","videoHeight","drawImage","dataURI","toDataURL","image","Image","src","eventDetail","file","fetch","size","blob","err","getCapabilities","getSettings","Boolean","defineCustomElement","elementName","window","customElements","define","CapturePhoto"],"version":3,"file":"capture-photo-defined.js.map"}